# The Playground engine

A small, experimental, data-driven, entity-component-based, and scriptable game engine.

## Compiling

The source code uses GCC pragmas and C++14.

#### Linux

On Linux, once the dependencies have been installed, just run `make` to build the program and run the tests. The result will appear in the `./Build` folder.

#### Windows

Compiling on Windows isn't a great experience at the moment. Your locations of the dependencies should be entered into the `*_COMP` and `*_LINK` fields, at the beginning of the Makefile. Once that has been done, the build is done the same way as on Linux.

## Organization

The C/C++ source code is in `src/`. The engine depends on some data, such as scriping files and shader source. These are located in `builtin/`.

Within `src/` lies a number of subfolders. These are usually fairly independent modules, some of which I've provided their own README file.

## Usage

The scene is described in a data file. The data is written in the JSON format. Each entity is listed as an object in a list. Each entity is composed of components, each of whom have their own object notation.

Currently the data file has to be written by hand, but in the future it will be generated by an editor.

A small look at the available components and their JSON notation follows.

#### Transform

This component describes the position, orientation, and scale of an entity. It's JSON notation is:

```json
"transform": {
  "position": [ NUMBER, NUMBER, NUMBER ],
  "rotation": [ NUMBER, NUMBER, NUMBER, NUMBER ],
  "scale": [ NUMBER, NUMBER, NUMBER ]
}
```

`position` is a 3d vector containing the world coordinates of the entity. `rotation` is a quaternion, and it's components should be normalized. `scale` is also a 3d vector, and its components should be non-zero.

#### Script

Entities can be scripted in Lua. The script component JSON notation simply contains the location of the script file.

```json
"script": STRING
```

#### Renderable

This component will be rendered with OpenGL. The component consists of a 3d model, and a shader. Currently, only the specular shader should be used at the moment.

*Component dependency: transform*

```json
"renderable": {
  "model": STRING,
  "material": {
    "shininess": NUMBER,
    "baseColor": [ NUMBER, NUMBER, NUMBER ],
    "ambientColor": [ NUMBER, NUMBER, NUMBER ],
    "specularColor": [ NUMBER, NUMBER, NUMBER ]
  }
}
```

`"model"` is the just the file path where the 3d model is located.

Here's the way shading works. The base color, diffuse color and specular color are all summed together to generate the final value. So if you want to turn, say specular shading, off, just set the specularColor elements to zero. The base color is what all the other colors are added on to, and it isn't affected by light.

#### Camera

The camera component is used for rendering the renderable components.

*Component dependency: transform*

```lua
"camera": {
  "fov": NUMBER,
  "nearPlane": NUMBER,
  "farPlane": NUMBER 
}
```

#### A small scene

Here is a simple scene where a cube light rotates around another 3d model:

`data/scene.json`:

```json
[
    {
        "transform": {
            "position": [ 0.0, 0.0, 8.0 ],
            "rotation": [ 0.0, 0.0, 0.0, 1.0 ],
            "scale": [ 1.0, 1.0, 1.0 ]
        },
        "camera": {
            "fov": 1.32,
            "nearPlane": 0.1,
            "farPlane": 10000
        }
    },
    {
        "script": "data/template.lua",
        "transform": {
            "position": [ -2.0, 0.0, 10.0 ],
            "rotation": [ 0.0, 0.0, 0.0, 1.0 ],
            "scale": [ 0.001, 0.001, 0.001 ]
        },
        "pointLight": {
            "intensity": [ 1.0, 1.0, 1.0 ],
            "attenuation": 0.5,
            "ambientCoefficient": 0.3
        },
        "renderable": {
            "model": "data/cube.dae",
            "material": {
                "shininess": 80.0,
                "specularColor": [ 0.0, 0.0, 0.0 ],
                "ambientColor": [ 1.0, 1.0, 1.0 ],
                "baseColor": [ 1.0, 1.0, 1.0 ]
            }
        }
    },
    {
        "transform": {
            "position": [ 0.0, 0.0, 0.0 ],
            "rotation": [ 0.0, 0.0, 0.0, 1.0 ],
            "scale": [ 1.0, 1.0, 1.0 ]
        },
        "renderable": {
            "model": "data/cow.obj",
            "material": {
                "shininess": 80.0,
                "specularColor": [ 1.0, 1.0, 1.0 ],
                "ambientColor": [ 0.941, 0.455, 0.804 ],
                "baseColor": [ 0.0, 0.0, 0.0 ]
            }
        }
    }
]
```

`data/template.lua`:

```lua
-- this gets called just after the component is assigned
function activate()
end

-- accumulated time
t = 0.0
-- angular velocity
av = 0.5
r = 5.0

-- this gets called in the update loop
function update( dt )
    t = t + dt
    if entity:hasTransform() then
        entity.transform.position = pg.Vector3f( r*math.cos(t), 0.0, r*math.sin(t))
    end
end

--  this gets called just before the component is removed
function deactivate()
    --this gets called just before the script gets removed from the owning entity
end
```

`config.json`:

```json
{
    "frameRate": 60.0,
    "window": {
        "width": 800,
        "height": 600,
        "name": "Playground engine",
        "opengl": {
            "major": 3,
            "minor": 1,
            "stencilBits": 8,
            "depthBits": 24,
            "msBuffers": 1,
            "msSamples": 4
        }
    }
}
```

## Scripting interface

**TODO: documentation**

## Dependencies
### SDL2
zlib license
Feel free to do anything you want with it, so long as you don't misrepresent who wrote the original software, license must be included
### glew
MIT license
### Lua 5.2
MIT license
### Assimp
3-clause BSD license, do what you want, but include the license text.
### LuaBridge
MIT license

